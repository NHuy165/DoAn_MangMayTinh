<!-- Main Content -->
<main data-page="screen">
    <div class="px-4 pt-6">
        <div class="grid gap-4 xl:grid-cols-1 2xl:grid-cols-2">
            <!-- Screen Controls -->
            <div class="p-4 bg-white border border-gray-200 rounded-lg shadow-sm 2xl:col-span-2 dark:border-gray-700 sm:p-6 dark:bg-gray-800">
                <h2 class="text-lg font-semibold text-gray-900 dark:text-white mb-4">Screen Controls</h2>

                <!-- Status Display -->
                <div class="mb-4">
                <div class="flex items-center space-x-4">
                    <div class="flex items-center">
                    <span class="text-sm font-medium text-gray-700 dark:text-gray-300 mr-2">Screen:</span>
                    <span id="stream-status" class="text-sm font-semibold text-gray-500 dark:text-gray-400">‚ö™ OFF</span>
                    </div>
                    <div class="flex items-center">
                    <span class="text-sm font-medium text-gray-700 dark:text-gray-300 mr-2">Recording:</span>
                    <span id="recording-status" class="text-sm font-semibold text-gray-500 dark:text-gray-400">‚ö™ STOPPED</span>
                    </div>
                    <div id="duration-display" class="flex items-center hidden">
                    <span class="text-sm font-medium text-gray-700 dark:text-gray-300 mr-2">Duration:</span>
                    <span id="recording-duration" class="text-sm font-semibold text-red-600 dark:text-red-400">00:00:00</span>
                    </div>
                </div>
                </div>

                <!-- Control Buttons -->
                <div class="flex space-x-3">
                <button id="turn-on-btn" type="button" class="text-gray-800 dark:text-white bg-green-600 hover:bg-green-700 focus:ring-4 focus:ring-green-300 font-medium rounded-lg text-sm px-5 py-2.5 dark:bg-green-500 dark:hover:bg-green-600 focus:outline-none dark:focus:ring-green-800">
                    üñ• Turn On Screen
                </button>
                <button id="turn-off-btn" type="button" disabled class="text-gray-800 dark:text-white bg-gray-400 font-medium rounded-lg text-sm px-5 py-2.5 cursor-not-allowed">
                    ‚èπ Turn Off Screen
                </button>
                <button id="start-rec-btn" type="button" disabled class="text-gray-800 dark:text-white bg-gray-400 font-medium rounded-lg text-sm px-5 py-2.5 cursor-not-allowed hidden">
                    üî¥ Start Recording
                </button>
                <button id="stop-rec-btn" type="button" disabled class="text-gray-800 dark:text-white bg-gray-400 font-medium rounded-lg text-sm px-5 py-2.5 cursor-not-allowed hidden">
                    ‚èπ Stop Recording
                </button>
                <button id="refresh-list-btn" type="button" class="text-gray-900 bg-white border border-gray-300 hover:bg-gray-100 focus:ring-4 focus:ring-gray-200 font-medium rounded-lg text-sm px-5 py-2.5 dark:bg-gray-800 dark:text-white dark:border-gray-600 dark:hover:bg-gray-700 dark:hover:border-gray-600 dark:focus:ring-gray-700">
                    üîÑ Refresh List
                </button>
                </div>
            </div>

            <!-- Live Preview -->
            <div id="preview-container" class="bg-gray-900 shadow rounded-lg mb-6 hidden">
                <div class="p-4">
                <h2 class="text-lg font-semibold text-white mb-4">Live Screen Preview</h2>
                <div class="flex justify-center bg-black rounded-lg overflow-hidden">
                    <img id="screen-preview" src="" alt="Screen Preview" class="max-w-full h-auto" style="max-height: 600px;">
                </div>
                <p class="text-sm text-gray-400 mt-2 text-center">Streaming live screen</p>
                </div>
            </div>

            <!-- Recordings List -->
            <div class="p-4 bg-white border border-gray-200 rounded-lg shadow-sm 2xl:col-span-2 dark:border-gray-700 sm:p-6 dark:bg-gray-800">
                <h2 class="text-lg font-semibold text-gray-900 dark:text-white mb-4">üóÇ Screen Recordings</h2>

                <div class="overflow-x-auto">
                <table class="min-w-full divide-y divide-gray-200 dark:divide-gray-700">
                    <thead class="bg-gray-50 dark:bg-gray-700">
                    <tr>
                        <th class="px-6 py-3 text-left text-xs font-medium text-gray-500 dark:text-gray-400 uppercase tracking-wider">Date/Time</th>
                        <th class="px-6 py-3 text-left text-xs font-medium text-gray-500 dark:text-gray-400 uppercase tracking-wider">Filename</th>
                        <th class="px-6 py-3 text-left text-xs font-medium text-gray-500 dark:text-gray-400 uppercase tracking-wider">Duration</th>
                        <th class="px-6 py-3 text-left text-xs font-medium text-gray-500 dark:text-gray-400 uppercase tracking-wider">Size</th>
                        <th class="px-6 py-3 text-left text-xs font-medium text-gray-500 dark:text-gray-400 uppercase tracking-wider">Actions</th>
                    </tr>
                    </thead>
                    <tbody id="recordings-list" class="bg-white divide-y divide-gray-200 dark:bg-gray-800 dark:divide-gray-700">
                    <tr>
                        <td colspan="5" class="px-6 py-4 text-center text-sm text-gray-500 dark:text-gray-400">No recordings yet.</td>
                    </tr>
                    </tbody>
                </table>
                </div>
            </div>

            </div>
    </div>
</main>

<script>
    function initScreenPage() {
        if (!document.querySelector('[data-page="screen"]')) return;

        const API = {
            ON: '/remote/api/screen/on', OFF: '/remote/api/screen/off', 
            STREAM: '/remote/api/screen/stream',
            REC_START: '/remote/api/screen/record/start', REC_STOP: '/remote/api/screen/record/stop',
            LIST: '/remote/api/screen/list', STATUS: '/remote/api/screen/status', 
            DELETE_BASE: '/remote/api/screen/delete/'
        };

        const turnOnBtn = document.getElementById('turn-on-btn');
        const turnOffBtn = document.getElementById('turn-off-btn');
        const startRecBtn = document.getElementById('start-rec-btn');
        const stopRecBtn = document.getElementById('stop-rec-btn');
        const refreshListBtn = document.getElementById('refresh-list-btn');
        const streamStatus = document.getElementById('stream-status');
        const recordingStatus = document.getElementById('recording-status');
        const durationDisplay = document.getElementById('duration-display');
        const recordingDuration = document.getElementById('recording-duration');
        const previewContainer = document.getElementById('preview-container');
        const screenPreview = document.getElementById('screen-preview');
        const recordingsList = document.getElementById('recordings-list');
        const originalStopBtnHtml = stopRecBtn.innerHTML;
        
        let isStreamOn = false;
        let isRecording = false;
        let streamInterval = null;
        let durationInterval = null;
        let recordingStartTime = null;

        // --- HELPER: SET BUTTON STATE ---
        function setBtnState(btn, isEnabled, activeColorClass, text = null) {
            if (!btn) return;
            if (text) btn.textContent = text;
            if (isEnabled) {
                btn.disabled = false;
                btn.classList.remove('bg-gray-400', 'cursor-not-allowed', 'hidden');
                const colors = activeColorClass.split(' ');
                btn.classList.add(...colors);
            } else {
                btn.disabled = true;
                const colors = activeColorClass.split(' ');
                btn.classList.remove(...colors);
                btn.classList.add('bg-gray-400', 'cursor-not-allowed');
            }
        }

        // --- RENDER UI ---
        function renderUI() {
            // --- PH·∫¶N 1: TR·∫†NG TH√ÅI STREAM (ON/OFF) ---
            if (isStreamOn) {
                // ƒêang Stream
                streamStatus.textContent = 'üü¢ ON';
                streamStatus.classList.add('text-green-600');
                previewContainer.classList.remove('hidden');

                // Disable n√∫t B·∫≠t, Enable n√∫t T·∫Øt
                setBtnState(turnOnBtn, false, 'bg-green-600 hover:bg-green-700', 'Screen On');
                setBtnState(turnOffBtn, true, 'bg-red-600 hover:bg-red-700');

                if (!streamInterval) startStreaming();
            } else {
                // T·∫Øt Stream
                streamStatus.textContent = '‚ö™ OFF';
                streamStatus.classList.remove('text-green-600');
                previewContainer.classList.add('hidden');

                // Enable n√∫t B·∫≠t, Disable n√∫t T·∫Øt
                setBtnState(turnOnBtn, true, 'bg-green-600 hover:bg-green-700', 'üñ• Turn On Screen');
                setBtnState(turnOffBtn, false, 'bg-red-600 hover:bg-red-700');

                stopStreaming();
            }

            // --- PH·∫¶N 2: TR·∫†NG TH√ÅI RECORDING (Ch·ªâ hi·ªán khi Stream ON) ---
            if (isStreamOn) {
                if (isRecording) {
                    // ƒêang Ghi h√¨nh
                    recordingStatus.textContent = 'üî¥ RECORDING';
                    recordingStatus.classList.add('text-red-600');
                    durationDisplay.classList.remove('hidden');

                    // ·∫®n n√∫t Start, Hi·ªán n√∫t Stop
                    startRecBtn.classList.add('hidden');
                    stopRecBtn.classList.remove('hidden');
                    
                    // [QUAN TR·ªåNG] Reset tr·∫°ng th√°i n√∫t Stop (S·ª≠a l·ªói hi·ªán ch·ªØ "Saving...")
                    stopRecBtn.disabled = false;
                    stopRecBtn.innerHTML = originalStopBtnHtml; 
                    
                    setBtnState(stopRecBtn, true, 'bg-red-600 hover:bg-red-700');
                } else {
                    // ƒê√£ d·ª´ng Ghi h√¨nh
                    recordingStatus.textContent = '‚ö™ STOPPED';
                    recordingStatus.classList.remove('text-red-600');
                    durationDisplay.classList.add('hidden');

                    // Hi·ªán n√∫t Start, ·∫®n n√∫t Stop
                    startRecBtn.classList.remove('hidden');
                    stopRecBtn.classList.add('hidden');

                    setBtnState(startRecBtn, true, 'bg-red-600 hover:bg-red-700');
                }
            } else {
                // N·∫øu Stream t·∫Øt -> ·∫®n to√†n b·ªô n√∫t Recording
                startRecBtn.classList.add('hidden');
                stopRecBtn.classList.add('hidden');
                durationDisplay.classList.add('hidden');
            }
        }

        function getCookie(name) {
            let cookieValue = null;
            if (document.cookie && document.cookie !== '') {
                const cookies = document.cookie.split(';');
                for (let i = 0; i < cookies.length; i++) {
                    const cookie = cookies[i].trim();
                    if (cookie.substring(0, name.length + 1) === (name + '=')) {
                        cookieValue = decodeURIComponent(cookie.substring(name.length + 1));
                        break;
                    }
                }
            }
            return cookieValue;
        }

        function updateDuration() {
            if (!recordingStartTime) return;
            const now = Date.now();
            const elapsed = Math.floor((now - recordingStartTime) / 1000);
            if (elapsed < 0) return;

            const h = Math.floor(elapsed / 3600);
            const m = Math.floor((elapsed % 3600) / 60);
            const s = elapsed % 60;
            recordingDuration.textContent =
                `${h.toString().padStart(2, '0')}:${m.toString().padStart(2, '0')}:${s.toString().padStart(2, '0')}`;
        }

        async function turnOnScreen() {
            if (localStorage.getItem('ACTIVE_STREAM_MODE') === 'WEBCAM') {
                showNotification("info", "Cannot start Screen Stream because Webcam is active!");
                return;
            }
            setBtnState(turnOnBtn, false, 'bg-green-600', 'Connecting...');
            try {
                const res = await fetch(API.ON, {
                    method: 'POST', headers: { 'X-CSRFToken': getCookie('csrftoken') }
                });
                const data = await res.json();
                if (data.success || data.message.includes('already')) {
                    isStreamOn = true;
                    localStorage.setItem('ACTIVE_STREAM_MODE', 'SCREEN');
                    setBtnState(turnOnBtn, true, 'bg-green-600', 'Screen On'); // Reset temp
                    renderUI();
                    setTimeout(updateStatus, 500);
                } else {
                    showNotification("error", data.message);
                    setBtnState(turnOnBtn, true, 'bg-green-600', 'üñ• Turn On Screen');
                }
            } catch (e) {
                console.error(e);
                setBtnState(turnOnBtn, true, 'bg-green-600', 'üñ• Turn On Screen');
            }
        }

        async function turnOffScreen() {
            setBtnState(turnOffBtn, false, 'bg-red-600');
            try {
                if (isRecording) await stopRecording();
                await fetch(API.OFF, {
                    method: 'POST', headers: { 'X-CSRFToken': getCookie('csrftoken') }
                });
                isStreamOn = false;
                localStorage.removeItem('ACTIVE_STREAM_MODE');
                setBtnState(turnOffBtn, true, 'bg-red-600');
                renderUI();
            } catch (e) { console.error(e); }
        }

        async function startRecording() {
            setBtnState(startRecBtn, false, 'bg-red-600');
            try {
                const res = await fetch(API.REC_START, {
                    method: 'POST', headers: { 'X-CSRFToken': getCookie('csrftoken') }
                });
                const data = await res.json();
                if (data.success) {
                    isRecording = true;
                    // L∆ØU STORAGE
                    recordingStartTime = Date.now();
                    localStorage.setItem('SCREEN_START_TIME', recordingStartTime);

                    // CH·∫†Y NGAY
                    updateDuration();
                    durationInterval = setInterval(updateDuration, 1000);
                    renderUI();
                } else {
                    showNotification("error", data.message);
                    setBtnState(startRecBtn, true, 'bg-red-600');
                }
            } catch (e) { console.error(e); setBtnState(startRecBtn, true, 'bg-red-600'); }
        }

        async function stopRecording() {
            setBtnState(stopRecBtn, false, 'bg-red-600', 'Saving...');
            try {
                const res = await fetch(API.REC_STOP, {
                    method: 'POST', headers: { 'X-CSRFToken': getCookie('csrftoken') }
                });
                const data = await res.json();
                if (data.success) {
                    isRecording = false;
                    clearInterval(durationInterval);
                    durationInterval = null;
                    localStorage.removeItem('SCREEN_START_TIME');

                    loadRecordingsList();
                    renderUI();
                    showNotification("success", `Saved: ${data.filename}`);
                }
            } catch (e) { 
                console.error(e); 
                showNotification("error", "Failed to stop recording.");
            }
            // finally { 
            //     setBtnState(stopRecBtn, true, 'bg-red-600', '‚èπ Stop Recording'); 
            // }
        }

        function startStreaming() {
            if (streamInterval) return;
            streamInterval = setInterval(() => {
                if (isStreamOn) screenPreview.src = API.STREAM + "?t=" + new Date().getTime();
            }, 250);
        }

        function stopStreaming() {
            if (streamInterval) { clearInterval(streamInterval); streamInterval = null; }
            screenPreview.src = '';
        }

        async function loadRecordingsList() {
            try {
                const res = await fetch(API.LIST);
                const data = await res.json();
                if (data.success && data.recordings.length > 0) {
                    recordingsList.innerHTML = data.recordings.map(rec => `
                        <tr>
                            <td class="px-6 py-4 text-sm text-gray-900 dark:text-white">${rec.recorded_at}</td>
                            <td class="px-6 py-4 text-sm text-gray-500">${rec.filename}</td>
                            <td class="px-6 py-4 text-sm text-gray-500">${rec.duration}</td>
                            <td class="px-6 py-4 text-sm text-gray-500">${rec.file_size}</td>
                            <td class="px-6 py-4 text-sm font-medium">
                                <a href="${rec.file_url}" download class="text-green-600 dark:text-green-400 hover:text-green-900 dark:hover:text-green-500 mr-3">Download</a>
                                <button onclick="deleteRecording(${rec.id})" class="text-red-600 hover:text-red-900 font-bold">Delete</button>
                            </td>
                        </tr>`).join('');
                } else {
                    recordingsList.innerHTML = '<tr><td colspan="5" class="px-6 py-4 text-center text-sm text-gray-500">No recordings yet.</td></tr>';
                }
            } catch (e) { console.error(e); }
        }

        window.deleteRecording = async function(id) {
            if (!confirm('Delete?')) return;
            res = await fetch(API.DELETE_BASE + id + '/', {
                method: 'DELETE', headers: { 'X-CSRFToken': getCookie('csrftoken') }
            });
            showNotification("success", "Recording deleted.");
            loadRecordingsList();
        };

        async function updateStatus() {
            try {
                const res = await fetch(API.STATUS);
                const data = await res.json();
                
                const serverOn = data.on || false;
                const serverRec = data.rec || false;

                // LOGIC SYNC TIMER
                if (serverRec) {
                    const savedTime = localStorage.getItem('SCREEN_START_TIME');
                    if (savedTime) {
                        recordingStartTime = parseInt(savedTime);
                    } else {
                        recordingStartTime = Date.now();
                        localStorage.setItem('SCREEN_START_TIME', recordingStartTime);
                    }
                    if (!durationInterval) {
                        // FIX LAG
                        updateDuration();
                        durationInterval = setInterval(updateDuration, 1000);
                    }
                } else {
                    if (durationInterval) {
                        clearInterval(durationInterval);
                        durationInterval = null;
                        localStorage.removeItem('SCREEN_START_TIME');
                    }
                }

                if (serverOn !== isStreamOn || serverRec !== isRecording) {
                    isStreamOn = serverOn;
                    isRecording = serverRec;
                    renderUI();

                    if(isStreamOn) localStorage.setItem('ACTIVE_STREAM_MODE', 'SCREEN');
                    else if(localStorage.getItem('ACTIVE_STREAM_MODE') === 'SCREEN') localStorage.removeItem('ACTIVE_STREAM_MODE');
                }
            } catch (e) { console.error(e); }
        }

        turnOnBtn.onclick = turnOnScreen;
        turnOffBtn.onclick = turnOffScreen;
        startRecBtn.onclick = startRecording;
        stopRecBtn.onclick = stopRecording;
        refreshListBtn.onclick = loadRecordingsList;

        loadRecordingsList();
        updateStatus();

        const interval = setInterval(() => {
            if (!document.querySelector('[data-page="screen"]')) {
                clearInterval(interval);
                stopStreaming();
                return;
            }
            updateStatus();
        }, 3000);
    }
    
    initScreenPage();
</script>