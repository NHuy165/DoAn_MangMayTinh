{% extends 'layouts/base.html' %}
{% load static %}

{% block title %}Screen Recorder{% endblock %}

{% block content %}

<div class="p-4">

  <!-- ===== Screen Controls ===== -->
  <div class="bg-white dark:bg-gray-800 shadow rounded-lg p-6 mb-6">
    <h2 class="text-lg font-semibold text-gray-900 dark:text-white mb-4">Screen Controls</h2>

    <!-- Status -->
    <div class="mb-4 flex flex-wrap items-center gap-6">
      <div class="flex items-center">
        <span class="text-sm font-medium text-gray-700 dark:text-gray-300 mr-2">Screen:</span>
        <span id="screen-status" class="text-sm font-semibold text-gray-500 dark:text-gray-400">‚ö™ OFF</span>
      </div>
      <div class="flex items-center">
        <span class="text-sm font-medium text-gray-700 dark:text-gray-300 mr-2">Recording:</span>
        <span id="recording-status" class="text-sm font-semibold text-gray-500 dark:text-gray-400">‚ö™ STOPPED</span>
      </div>
      <div id="duration-display" class="flex items-center hidden">
        <span class="text-sm font-medium text-gray-700 dark:text-gray-300 mr-2">Duration:</span>
        <span id="recording-duration" class="text-sm font-semibold text-red-600">00:00:00</span>
      </div>
    </div>

    <!-- Buttons -->
    <div class="flex flex-wrap gap-3">
      <button id="btn-on" class="px-5 py-2.5 rounded-lg text-sm font-medium text-white bg-green-600 hover:bg-green-700">üñ• Turn On Screen</button>
      <button id="btn-off" class="px-5 py-2.5 rounded-lg text-sm font-medium text-white bg-red-600 hover:bg-red-700 hidden">‚èπ Turn Off Screen</button>
      <button id="btn-rec-start" class="px-5 py-2.5 rounded-lg text-sm font-medium text-white bg-red-600 hover:bg-red-700 hidden">üî¥ Start Recording</button>
      <button id="btn-rec-stop" class="px-5 py-2.5 rounded-lg text-sm font-medium text-white bg-red-600 hover:bg-red-700 hidden">‚èπ Stop Recording</button>
      <button id="btn-refresh" class="px-5 py-2.5 rounded-lg text-sm font-medium border border-gray-300 bg-white hover:bg-gray-100 dark:bg-gray-800 dark:text-white">üîÑ Refresh List</button>
    </div>
  </div>

  <!-- ===== Live Preview ===== -->
  <div id="preview-container" class="bg-gray-900 shadow rounded-lg mb-6 hidden">
    <div class="p-4">
      <h2 class="text-lg font-semibold text-white mb-4">Live Preview</h2>
      <div class="flex justify-center bg-black rounded-lg overflow-hidden">
        <img id="screen-preview" src="" class="max-w-full h-auto" style="max-height:600px" />
      </div>
      <p class="text-sm text-gray-400 mt-2 text-center">Streaming ~5 FPS</p>
    </div>
  </div>

  <!-- ===== Recordings List ===== -->
  <div class="bg-white dark:bg-gray-800 shadow rounded-lg p-6">
    <h2 class="text-lg font-semibold text-gray-900 dark:text-white mb-4">üìπ Recorded Screens</h2>

    <div class="overflow-x-auto">
      <table class="min-w-full divide-y divide-gray-200 dark:divide-gray-700">
        <thead class="bg-gray-50 dark:bg-gray-700">
          <tr>
            <th class="px-6 py-3 text-left text-xs font-medium text-gray-500 dark:text-gray-400 uppercase tracking-wider">Date/Time</th>
            <th class="px-6 py-3 text-left text-xs font-medium text-gray-500 dark:text-gray-400 uppercase tracking-wider">Filename</th>
            <th class="px-6 py-3 text-left text-xs font-medium text-gray-500 dark:text-gray-400 uppercase tracking-wider">Duration</th>
            <th class="px-6 py-3 text-left text-xs font-medium text-gray-500 dark:text-gray-400 uppercase tracking-wider">Size</th>
            <th class="px-6 py-3 text-left text-xs font-medium text-gray-500 dark:text-gray-400 uppercase tracking-wider">Actions</th>
          </tr>
        </thead>
        <tbody id="recording-list" class="bg-white divide-y divide-gray-200 dark:bg-gray-800 dark:divide-gray-700">
          <tr>
            <td colspan="5" class="px-6 py-4 text-center text-sm text-gray-500 dark:text-gray-400">No recordings yet</td>
          </tr>
        </tbody>
      </table>
    </div>
  </div>
</div>
{% endblock content %}

{% block extra_js %}

<script>
document.addEventListener('DOMContentLoaded', () => {

  /* ==================== API ==================== */
  const API = {
    on: '/remote/api/screen/on',
    off: '/remote/api/screen/off',
    stream: '/remote/api/screen/stream',
    recStart: '/remote/api/screen/record/start',
    recStop: '/remote/api/screen/record/stop',
    list: '/remote/api/screen/list',
    status: '/remote/api/screen/status'
  }

  /* ==================== STATE ==================== */
  const screenState = {
    serverConnected: false,
    screenOn: false,
    recording: false
  }

  /* ==================== DOM ==================== */
  const els = {
    on: document.getElementById('btn-on'),
    off: document.getElementById('btn-off'),
    rs: document.getElementById('btn-rec-start'),
    re: document.getElementById('btn-rec-stop'),
    refresh: document.getElementById('btn-refresh'),

    status: document.getElementById('screen-status'),
    recStatus: document.getElementById('recording-status'),
    durationBox: document.getElementById('duration-display'),
    duration: document.getElementById('recording-duration'),

    previewWrap: document.getElementById('preview-container'),
    preview: document.getElementById('screen-preview'),
    list: document.getElementById('recording-list'),

    disconnect: document.getElementById('disconnect-server-btn')
  }

  /* ==================== RUNTIME ==================== */
  let streamInterval = null
  let durationInterval = null
  let recordingStartTime = null
  let lastFrameAt = Date.now()
  let hasHandledDisconnect = false

  /* ==================== WATCHDOG ==================== */
  setInterval(() => {
    if (
      screenState.serverConnected &&
      screenState.screenOn &&
      Date.now() - lastFrameAt > 3000
    ) {
      console.warn('üö® Screen stream timeout')
      handleServerDisconnected()
    }
  }, 1000)

  /* ==================== DISCONNECT BTN ==================== */
  function updateDisconnectBtn(recording) {
    if (!els.disconnect) return; // an to√†n n·∫øu n√∫t ch∆∞a t·ªìn t·∫°i
    els.disconnect.disabled = recording; // disable khi recording=true
    els.disconnect.classList.toggle('opacity-50', recording); // optional: m·ªù n√∫t khi disable
  }

  /* ==================== STREAM ==================== */
  function startStreaming() {
    if (streamInterval) return

    streamInterval = setInterval(async () => {
      try {
        const res = await fetch(API.stream)
        if (!res.ok) throw new Error('stream failed')

        const blob = await res.blob()
        if (blob.size > 0) {
          lastFrameAt = Date.now()
          const url = URL.createObjectURL(blob)
          els.preview.src = url
          setTimeout(() => URL.revokeObjectURL(url), 1000)
        }
      } catch (e) {
        console.warn('stream error:', e.message)
      }
    }, 200) // ~5 FPS
  }

  function stopStreaming() {
    if (streamInterval) {
      clearInterval(streamInterval)
      streamInterval = null
    }
    els.preview.src = ''
  }

  /* ==================== DURATION ==================== */
  function updateDuration() {
    if (!recordingStartTime) return
    const s = Math.floor((Date.now() - recordingStartTime) / 1000)
    const h = String(Math.floor(s / 3600)).padStart(2, '0')
    const m = String(Math.floor((s % 3600) / 60)).padStart(2, '0')
    const ss = String(s % 60).padStart(2, '0')
    els.duration.textContent = `${h}:${m}:${ss}`
  }

  /* ==================== ACTIONS ==================== */
  async function turnOnScreen() {
    els.on.disabled = true
    try {
      const r = await fetch(API.on, { method: 'POST' })
      const d = await r.json()
      if (!d.success) throw new Error()

      hasHandledDisconnect = false
      screenState.serverConnected = true
      screenState.screenOn = true

      els.status.textContent = 'üü¢ ON'
      els.status.classList.add('text-green-600')
      els.status.classList.remove('text-gray-500')

      els.previewWrap.classList.remove('hidden')
      els.on.classList.add('hidden')
      els.off.classList.remove('hidden')
      els.rs.classList.remove('hidden')

      lastFrameAt = Date.now()
      startStreaming()
    } catch {
      alert('‚ùå Failed to turn on screen')
    } finally {
      els.on.disabled = false
    }
  }

  async function turnOffScreen() {
    els.off.disabled = true
    try {
      if (screenState.recording) {
        await stopRecording()
      }

      await fetch(API.off, { method: 'POST' })

      screenState.screenOn = false
      screenState.recording = false

      stopStreaming()
      resetUI()
    } catch {
      alert('‚ùå Failed to turn off screen')
    } finally {
      els.off.disabled = false
    }
  }

  async function startRecording() {
    els.rs.disabled = true
    try {
      const r = await fetch(API.recStart, { method: 'POST' })
      const d = await r.json()
      if (!d.success) throw new Error()

      screenState.recording = true

      els.recStatus.textContent = 'üî¥ RECORDING'
      els.recStatus.classList.add('text-red-600')
      els.recStatus.classList.remove('text-gray-500')

      els.durationBox.classList.remove('hidden')
      recordingStartTime = Date.now()
      durationInterval = setInterval(updateDuration, 1000)

      els.rs.classList.add('hidden')
      els.re.classList.remove('hidden')

      updateDisconnectBtn(true); // disable n√∫t
    } catch {
      alert('‚ùå Failed to start recording')
    } finally {
      els.rs.disabled = false
    }
  }

  async function stopRecording() {
    els.re.disabled = true
    try {
      const r = await fetch(API.recStop, { method: 'POST' })
      const d = await r.json()
      if (!d.success) throw new Error()

      screenState.recording = false

      if (durationInterval) clearInterval(durationInterval)
      durationInterval = null
      recordingStartTime = null

      els.durationBox.classList.add('hidden')
      els.recStatus.textContent = '‚ö™ STOPPED'
      els.recStatus.classList.remove('text-red-600')
      els.recStatus.classList.add('text-gray-500')

      els.re.classList.add('hidden')
      els.rs.classList.remove('hidden')

      updateDisconnectBtn(false); // enable n√∫t

      loadList()
    } catch {
      alert('‚ùå Failed to stop recording')
    } finally {
      els.re.disabled = false
    }
  }

  /* ==================== LIST ==================== */
  async function loadList() {
    try {
      const r = await fetch(API.list)
      const d = await r.json()
      if (!d.success || !d.recordings.length) {
        els.list.innerHTML =
          `<tr><td colspan="5" class="px-6 py-4 text-center text-sm text-gray-500 dark:text-gray-400">No recordings</td></tr>`
        return
      }

      els.list.innerHTML = d.recordings.map(x => `
        <tr>
          <td class="px-6 py-4 whitespace-nowrap text-sm text-gray-900 dark:text-white">${x.recorded_at}</td>
          <td class="px-6 py-4 whitespace-nowrap text-sm text-gray-900 dark:text-white">${x.filename}</td>
          <td class="px-6 py-4 whitespace-nowrap text-sm text-gray-900 dark:text-white">${x.duration}</td>
          <td class="px-6 py-4 whitespace-nowrap text-sm text-gray-900 dark:text-white">${x.file_size}</td>
          <td class="px-6 py-4 whitespace-nowrap text-sm text-gray-900 dark:text-white">
            
            <a href="${x.file_url}" target="_blank" class="text-blue-600 hover:text-blue-900 dark:text-blue-400 mr-3">View</a>
            <a href="${x.file_url}" download class="text-green-600 hover:text-green-900 dark:text-green-400 mr-3">Download</a>
            <button onclick="deleteRecording(${x.id})" class="text-red-600 hover:text-red-900 dark:text-red-400">Delete</button>
          </td>
        </tr>`).join('')
    } catch (e) {
      console.error('load list failed')
    }
  }
  
  window.deleteRecording = async function(id) {
      if (!confirm('Are you sure you want to delete this recording?')) return;
      
      try {
        const response = await fetch(`/remote/api/screen/delete/${id}/`, {
          method: 'DELETE',
          headers: {
            'X-CSRFToken': getCookie('csrftoken')
          }
        });
        
        const data = await response.json();
        
        if (data.success) {
          showNotification('success', 'Recording deleted');
          await loadRecordingsList();
        } else {
          showNotification('error', data.message);
        }
      } catch (error) {
        showNotification('error', 'Failed to delete recording: ' + error.message);
      }
    };

  /* ==================== DISCONNECT ==================== */
  function handleServerDisconnected() {
    if (hasHandledDisconnect) return
    hasHandledDisconnect = true

    console.warn('üö® Screen server disconnected')

    screenState.serverConnected = false
    screenState.screenOn = false
    screenState.recording = false

    stopStreaming()

    if (durationInterval) clearInterval(durationInterval)
    durationInterval = null
    recordingStartTime = null

    resetUI()

    alert('‚Ñπ Disconnected from server. Recording has been saved automatically.')
  }

  function resetUI() {
    els.previewWrap.classList.add('hidden')

    els.on.classList.remove('hidden')
    els.off.classList.add('hidden')
    els.rs.classList.add('hidden')
    els.re.classList.add('hidden')

    els.durationBox.classList.add('hidden')

    els.status.textContent = '‚ö™ OFF (Disconnected)'
    els.status.classList.remove('text-green-600')
    els.status.classList.add('text-gray-500')

    els.recStatus.textContent = '‚ö™ STOPPED'
    els.recStatus.classList.remove('text-red-600')
    els.recStatus.classList.add('text-gray-500')
  }

  /* ==================== STATUS POLLING ==================== */
  setInterval(async () => {
    try {
      const r = await fetch(API.status)
      if (!r.ok) throw new Error()
      screenState.serverConnected = true
    } catch {
      handleServerDisconnected()
    }
  }, 3000)

  /* ==================== EVENTS ==================== */
  els.on.onclick = turnOnScreen
  els.off.onclick = turnOffScreen
  els.rs.onclick = startRecording
  els.re.onclick = stopRecording
  els.refresh.onclick = loadList

  /* ==================== INIT ==================== */
  loadList()
})
</script>
{% endblock extra_js %}