{% extends 'layouts/base.html' %}
{% load static %}

{% block title %}Screen Recorder{% endblock %}

{% block content %}

<div class="p-4">

  <div class="bg-white dark:bg-gray-800 shadow rounded-lg p-6 mb-6">
    <h2 class="text-lg font-semibold text-gray-900 dark:text-white mb-4">Screen Controls</h2>

    <div class="mb-4 flex flex-wrap items-center gap-6">
      <div class="flex items-center">
        <span class="text-sm font-medium text-gray-700 dark:text-gray-300 mr-2">Screen:</span>
        <span id="screen-status" class="text-sm font-semibold text-gray-500 dark:text-gray-400">‚ö™ OFF</span>
      </div>
      <div class="flex items-center">
        <span class="text-sm font-medium text-gray-700 dark:text-gray-300 mr-2">Recording:</span>
        <span id="recording-status" class="text-sm font-semibold text-gray-500 dark:text-gray-400">‚ö™ STOPPED</span>
      </div>
      <div id="duration-display" class="flex items-center hidden">
        <span class="text-sm font-medium text-gray-700 dark:text-gray-300 mr-2">Duration:</span>
        <span id="recording-duration" class="text-sm font-semibold text-red-600">00:00:00</span>
      </div>
    </div>

    <div class="flex flex-wrap gap-3">
      <button id="btn-on" class="px-5 py-2.5 rounded-lg text-sm font-medium text-white bg-green-600 hover:bg-green-700">üñ• Turn On Screen</button>
      <button id="btn-off" class="px-5 py-2.5 rounded-lg text-sm font-medium text-white bg-red-600 hover:bg-red-700 hidden">‚èπ Turn Off Screen</button>
      <button id="btn-rec-start" class="px-5 py-2.5 rounded-lg text-sm font-medium text-white bg-red-600 hover:bg-red-700 hidden">üî¥ Start Recording</button>
      <button id="btn-rec-stop" class="px-5 py-2.5 rounded-lg text-sm font-medium text-white bg-red-600 hover:bg-red-700 hidden">‚èπ Stop Recording</button>
      <button id="btn-refresh" class="px-5 py-2.5 rounded-lg text-sm font-medium border border-gray-300 bg-white hover:bg-gray-100 dark:bg-gray-800 dark:text-white">üîÑ Refresh List</button>
    </div>
  </div>

  <div id="preview-container" class="bg-gray-900 shadow rounded-lg mb-6 hidden">
    <div class="p-4">
      <h2 class="text-lg font-semibold text-white mb-4">Live Preview</h2>
      <div class="flex justify-center bg-black rounded-lg overflow-hidden">
        <img id="screen-preview" src="" class="max-w-full h-auto" style="max-height:600px" />
      </div>
      <p class="text-sm text-gray-400 mt-2 text-center">Streaming Live</p>
    </div>
  </div>

  <div class="bg-white dark:bg-gray-800 shadow rounded-lg p-6">
    <h2 class="text-lg font-semibold text-gray-900 dark:text-white mb-4">üìπ Recorded Screens</h2>

    <div class="overflow-x-auto">
      <table class="min-w-full divide-y divide-gray-200 dark:divide-gray-700">
        <thead class="bg-gray-50 dark:bg-gray-700">
          <tr>
            <th class="px-6 py-3 text-left text-xs font-medium text-gray-500 dark:text-gray-400 uppercase tracking-wider">Date/Time</th>
            <th class="px-6 py-3 text-left text-xs font-medium text-gray-500 dark:text-gray-400 uppercase tracking-wider">Filename</th>
            <th class="px-6 py-3 text-left text-xs font-medium text-gray-500 dark:text-gray-400 uppercase tracking-wider">Duration</th>
            <th class="px-6 py-3 text-left text-xs font-medium text-gray-500 dark:text-gray-400 uppercase tracking-wider">Size</th>
            <th class="px-6 py-3 text-left text-xs font-medium text-gray-500 dark:text-gray-400 uppercase tracking-wider">Actions</th>
          </tr>
        </thead>
        <tbody id="recording-list" class="bg-white divide-y divide-gray-200 dark:bg-gray-800 dark:divide-gray-700">
          <tr>
            <td colspan="5" class="px-6 py-4 text-center text-sm text-gray-500 dark:text-gray-400">No recordings yet</td>
          </tr>
        </tbody>
      </table>
    </div>
  </div>
</div>
{% endblock content %}

{% block extra_js %}
<script>
document.addEventListener('DOMContentLoaded', () => {

  /* ==================== API ==================== */
  const API = {
    on: '/remote/api/screen/on',
    off: '/remote/api/screen/off',
    stream: '/remote/api/screen/stream',
    recStart: '/remote/api/screen/record/start',
    recStop: '/remote/api/screen/record/stop',
    list: '/remote/api/screen/list',
    status: '/remote/api/screen/status',
    delete: '/remote/api/screen/delete/' 
  }

  /* ==================== STATE ==================== */
  const screenState = {
    serverConnected: false,
    screenOn: false,
    recording: false
  }

  /* ==================== DOM ==================== */
  const els = {
    on: document.getElementById('btn-on'),
    off: document.getElementById('btn-off'),
    rs: document.getElementById('btn-rec-start'),
    re: document.getElementById('btn-rec-stop'),
    refresh: document.getElementById('btn-refresh'),

    status: document.getElementById('screen-status'),
    recStatus: document.getElementById('recording-status'),
    durationBox: document.getElementById('duration-display'),
    duration: document.getElementById('recording-duration'),

    previewWrap: document.getElementById('preview-container'),
    preview: document.getElementById('screen-preview'),
    list: document.getElementById('recording-list'),
    
    disconnect: document.getElementById('disconnect-server-btn') // N√∫t disconnect ·ªü navbar (n·∫øu c√≥)
  }

  /* ==================== HELPER ==================== */
  function getCookie(name) {
      let cookieValue = null;
      if (document.cookie && document.cookie !== '') {
        const cookies = document.cookie.split(';');
        for (let i = 0; i < cookies.length; i++) {
          const cookie = cookies[i].trim();
          if (cookie.substring(0, name.length + 1) === (name + '=')) {
            cookieValue = decodeURIComponent(cookie.substring(name.length + 1));
            break;
          }
        }
      }
      return cookieValue;
  }

  function showNotification(type, message) {
      const colors = {'success': '‚úì', 'error': '‚úó', 'info': '‚Ñπ'};
      alert(`${colors[type] || ''} ${message}`);
  }


  /* ==================== RUNTIME ==================== */
  let streamInterval = null
  let durationInterval = null
  let recordingStartTime = null
  let lastFrameAt = Date.now()
  let hasHandledDisconnect = false

  /* ==================== WATCHDOG (FIXED) ==================== */
  setInterval(() => {
    // S·ª¨A: Ch·ªâ log c·∫£nh b√°o, KH√îNG t·ª± disconnect khi lag
    if (
      screenState.serverConnected &&
      screenState.screenOn &&
      Date.now() - lastFrameAt > 5000 
    ) {
      console.warn('üö® Screen stream timeout (Lag only - connection kept alive)')
    }
  }, 1000)


  /* ==================== STREAM ==================== */
  function startStreaming() {
    if (streamInterval) return

    streamInterval = setInterval(async () => {
      try {
        if (els.re.disabled) return; // N·∫øu ƒëang ch·ªù stop th√¨ pause request

        const res = await fetch(API.stream)
        if (!res.ok) {
           console.warn('Frame skip');
           return;
        }

        const blob = await res.blob()
        if (blob.size > 0) {
          lastFrameAt = Date.now()
          const url = URL.createObjectURL(blob)
          els.preview.src = url
          setTimeout(() => URL.revokeObjectURL(url), 1000)
        }
      } catch (e) {
        console.warn('stream error:', e.message)
      }
    }, 200) // 5 FPS
  }

  function stopStreaming() {
    if (streamInterval) {
      clearInterval(streamInterval)
      streamInterval = null
    }
    els.preview.src = ''
  }

  /* ==================== DURATION ==================== */
  function updateDuration() {
    if (!recordingStartTime) return
    const s = Math.floor((Date.now() - recordingStartTime) / 1000)
    const h = String(Math.floor(s / 3600)).padStart(2, '0')
    const m = String(Math.floor((s % 3600) / 60)).padStart(2, '0')
    const ss = String(s % 60).padStart(2, '0')
    els.duration.textContent = `${h}:${m}:${ss}`
  }

  /* ==================== ACTIONS ==================== */
  async function turnOnScreen() {
    els.on.disabled = true
    try {
      const r = await fetch(API.on, { 
          method: 'POST', 
          headers: {'X-CSRFToken': getCookie('csrftoken')}
      })
      const d = await r.json()
      if (!d.success) throw new Error(d.message || 'Failed to turn on screen')

      hasHandledDisconnect = false
      screenState.serverConnected = true
      screenState.screenOn = true

      els.status.textContent = 'üü¢ ON'
      els.status.classList.add('text-green-600')
      els.status.classList.remove('text-gray-500')

      els.previewWrap.classList.remove('hidden')
      els.on.classList.add('hidden')
      els.off.classList.remove('hidden')
      els.rs.classList.remove('hidden')

      lastFrameAt = Date.now()
      startStreaming()
      showNotification('success', 'Screen turned ON')
    } catch (e) {
      showNotification('error', e.message)
    } finally {
      els.on.disabled = false
    }
  }

  async function turnOffScreen() {
    els.off.disabled = true
    try {
      if (screenState.recording) {
        await stopRecording()
      }

      await fetch(API.off, { 
          method: 'POST', 
          headers: {'X-CSRFToken': getCookie('csrftoken')}
      })

      screenState.screenOn = false
      screenState.recording = false

      stopStreaming()
      resetUI()
      showNotification('success', 'Screen turned OFF')
    } catch {
      showNotification('error', 'Failed to turn off screen')
    } finally {
      els.off.disabled = false
    }
  }

  async function startRecording() {
    els.rs.disabled = true
    try {
      const r = await fetch(API.recStart, { 
          method: 'POST', 
          headers: {'X-CSRFToken': getCookie('csrftoken')}
      })
      const d = await r.json()
      if (!d.success) throw new Error()

      screenState.recording = true

      els.recStatus.textContent = 'üî¥ RECORDING'
      els.recStatus.classList.add('text-red-600')
      els.recStatus.classList.remove('text-gray-500')

      els.durationBox.classList.remove('hidden')
      recordingStartTime = Date.now()
      durationInterval = setInterval(updateDuration, 1000)

      els.rs.classList.add('hidden')
      els.re.classList.remove('hidden')

      showNotification('success', 'Recording STARTED')
    } catch {
      showNotification('error', 'Failed to start recording')
    } finally {
      els.rs.disabled = false
    }
  }

  async function stopRecording() {
    // ∆Øu ti√™n ng·∫Øt stream ƒë·ªÉ l·ªánh stop ƒëi nhanh h∆°n
    stopStreaming() 
    
    els.re.disabled = true
    try {
      const r = await fetch(API.recStop, { 
          method: 'POST', 
          headers: {'X-CSRFToken': getCookie('csrftoken')}
      })
      const d = await r.json()
      if (!d.success) throw new Error()

      screenState.recording = false

      if (durationInterval) clearInterval(durationInterval)
      durationInterval = null
      recordingStartTime = null

      els.durationBox.classList.add('hidden')
      els.recStatus.textContent = '‚ö™ STOPPED'
      els.recStatus.classList.remove('text-red-600')
      els.recStatus.classList.add('text-gray-500')

      els.re.classList.add('hidden')
      els.rs.classList.remove('hidden')

      loadList()
      
      showNotification('success', `Saved: ${d.filename} (${d.file_size})`)
      
      // M·ªü l·∫°i stream n·∫øu ch∆∞a t·∫Øt m√†n h√¨nh
      if (screenState.screenOn) startStreaming()

    } catch (e) {
      showNotification('error', 'Failed to stop recording')
      // L·ªói c≈©ng th·ª≠ m·ªü l·∫°i stream
      if (screenState.screenOn) startStreaming()
    } finally {
      els.re.disabled = false
    }
  }

  /* ==================== LIST ==================== */
  async function loadList() {
    try {
      const r = await fetch(API.list)
      const d = await r.json()
      if (!d.success || !d.recordings.length) {
        els.list.innerHTML =
          `<tr><td colspan="5" class="px-6 py-4 text-center text-sm text-gray-500 dark:text-gray-400">No recordings</td></tr>`
        return
      }

      els.list.innerHTML = d.recordings.map(x => `
        <tr>
          <td class="px-6 py-4 whitespace-nowrap text-sm text-gray-900 dark:text-white">${x.recorded_at}</td>
          <td class="px-6 py-4 whitespace-nowrap text-sm text-gray-900 dark:text-white">${x.filename}</td>
          <td class="px-6 py-4 whitespace-nowrap text-sm text-gray-900 dark:text-white">${x.duration}</td>
          <td class="px-6 py-4 whitespace-nowrap text-sm text-gray-900 dark:text-white">${x.file_size}</td>
          <td class="px-6 py-4 whitespace-nowrap text-sm text-gray-900 dark:text-white">
            <a href="${x.file_url}" target="_blank" class="text-blue-600 hover:text-blue-900 dark:text-blue-400 mr-3">View</a>
            <a href="${x.file_url}" download class="text-green-600 hover:text-green-900 dark:text-green-400 mr-3">Download</a>
            <button onclick="deleteRecording(${x.id})" class="text-red-600 hover:text-red-900 dark:text-red-400">Delete</button>
          </td>
        </tr>`).join('')
    } catch (e) {
      console.error('load list failed')
    }
  }
  
  // H√†m delete (ƒë√£ s·ª≠a URL trong API object)
  window.deleteRecording = async function(id) {
      if (!confirm('Are you sure you want to delete this recording?')) return;
      try {
        const response = await fetch(`${API.delete}${id}/`, {
          method: 'DELETE',
          headers: {'X-CSRFToken': getCookie('csrftoken')}
        });
        const data = await response.json();
        if (data.success) {
          showNotification('success', 'Recording deleted');
          await loadList();
        } else {
          showNotification('error', data.message);
        }
      } catch (error) {
        showNotification('error', 'Failed to delete: ' + error.message);
      }
  };

  /* ==================== DISCONNECT ==================== */
  function handleServerDisconnected() {
    if (hasHandledDisconnect) return;
    hasHandledDisconnect = true;

    console.warn('üö® Screen server disconnected (Real status check)');

    // Reset tr·∫°ng th√°i UI v·ªÅ OFF
    screenState.serverConnected = false;
    screenState.screenOn = false;
    screenState.recording = false;

    stopStreaming(); // D·ª´ng request ·∫£nh

    if (durationInterval) clearInterval(durationInterval);
    durationInterval = null;
    recordingStartTime = null;

    resetUI(); // ƒê·ªïi n√∫t b·∫•m v√† m√†u s·∫Øc

    // Th√¥ng b√°o chung chung, kh√¥ng h·ª©a h·∫πn l√† "ƒë√£ l∆∞u file" n·ªØa
    showNotification('info', 'Lost connection to server. Please check the network.');
  }

  function resetUI() {
    els.previewWrap.classList.add('hidden')

    els.on.classList.remove('hidden')
    els.off.classList.add('hidden')
    els.rs.classList.add('hidden')
    els.re.classList.add('hidden')

    els.durationBox.classList.add('hidden')

    els.status.textContent = '‚ö™ OFF (Disconnected)'
    els.status.classList.remove('text-green-600')
    els.status.classList.add('text-gray-500')

    els.recStatus.textContent = '‚ö™ STOPPED'
    els.recStatus.classList.remove('text-red-600')
    els.recStatus.classList.add('text-gray-500')
  }

  /* ==================== STATUS POLLING ==================== */
  async function checkStatus() {
    try {
      const r = await fetch(API.status)
      if (!r.ok) throw new Error()
      
      const data = await r.json()
      
      // 1. STREAM STATUS
      // Logic: N·∫øu tr·∫°ng th√°i thay ƒë·ªïi HO·∫∂C (server ƒëang ON m√† client ch∆∞a stream)
      if (data.stream_on !== screenState.screenOn || (data.stream_on && !streamInterval)) {
         
         if (data.stream_on) {
             hasHandledDisconnect = false;
             screenState.screenOn = true;
             
             // Update Text
             els.status.textContent = 'üü¢ ON';
             els.status.classList.add('text-green-600');
             els.status.classList.remove('text-gray-500');
             
             // Update Khung h√¨nh
             els.previewWrap.classList.remove('hidden');
             
             // --- UPDATE N√öT B·∫§M (QUAN TR·ªåNG) ---
             els.on.classList.add('hidden');        // ·∫®n n√∫t Turn On
             els.off.classList.remove('hidden');    // Hi·ªán n√∫t Turn Off
             els.rs.classList.remove('hidden');     // Hi·ªán n√∫t Start Rec
             
             startStreaming();
         } else {
             screenState.screenOn = false;
             
             // Update Text
             els.status.textContent = '‚ö™ OFF';
             els.status.classList.remove('text-green-600');
             
             // Reset UI v·ªÅ m·∫∑c ƒë·ªãnh
             els.previewWrap.classList.add('hidden');
             els.on.classList.remove('hidden');     // Hi·ªán l·∫°i n√∫t Turn On
             els.off.classList.add('hidden');
             els.rs.classList.add('hidden');
             els.re.classList.add('hidden');
             
             stopStreaming();
         }
      }

      // 2. RECORDING STATUS
      if (data.recording !== screenState.recording) {
          screenState.recording = data.recording;
          if (data.recording) {
              els.recStatus.textContent = 'üî¥ RECORDING';
              els.recStatus.classList.add('text-red-600');
              els.recStatus.classList.remove('text-gray-500');
              
              // ƒêang quay: ·∫®n Start, Hi·ªán Stop
              els.rs.classList.add('hidden');
              els.re.classList.remove('hidden');
          } else {
              els.recStatus.textContent = '‚ö™ STOPPED';
              els.recStatus.classList.remove('text-red-600');
              
              // D·ª´ng quay: Hi·ªán Start (n·∫øu m√†n h√¨nh ƒëang m·ªü), ·∫®n Stop
              if (screenState.screenOn) {
                  els.rs.classList.remove('hidden');
              }
              els.re.classList.add('hidden');
          }
      }

      screenState.serverConnected = true
    } catch {
      handleServerDisconnected()
    }
  }

  // 2. G·ªçi h√†m NGAY L·∫¨P T·ª®C khi v√†o trang (S·ª≠a l·ªói lag 3-4s)
  checkStatus();

  // 3. Sau ƒë√≥ m·ªõi ƒë·∫∑t l·ªãch l·∫∑p l·∫°i m·ªói 3s
  setInterval(checkStatus, 3000);

  /* ==================== EVENTS ==================== */
  els.on.onclick = turnOnScreen
  els.off.onclick = turnOffScreen
  els.rs.onclick = startRecording
  els.re.onclick = stopRecording
  els.refresh.onclick = loadList

  /* ==================== INIT ==================== */
  loadList()
})
</script>
{% endblock extra_js %}